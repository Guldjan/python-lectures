= slide 'Операционни системи' do
    list:
        Парчета код, които управляват хардуера
        Позволяват изпълнението на потребителски програми
        Има ги разни (Windows/Linux/OS X)


= slide 'Kernel' do
    list:
        Ядрото (duh) на операционната система
        Има пряк достъп до всичко в компютъра ви
        Грижи се за потребителските програми


= slide 'Драйвъри' do
    list:
        Парчета код в ядрото, които управляват конкретен хардуер
        Могат да се слагат отделно от ОС-а


= slide 'Userland' do
    list:
        "GNU" частта от "GNU/Linux"
        Полезните програмки, без които една ОС е безполезна
        Текстови редактори, web browser-и, терминали, графични среди, etc


= slide 'User space / Kernel space' do
    list:
        Userland частта вървят в първото
        Kernel-a върви във второто
        Това е грубо казано, демек е омешано, но така е в общия случай
        Няма общо с root (Linux)/Administrator (Windows)
        Защо е това разделение?
        Сигурност: между отделните процеси, както и между тях и ядрото


= slide '... а какво всъщност са процеси?' do
    list:
        Това са потребителските програми
        Всеки е разделен от всички останали
        Всеки има свое виждане за паметта


= slide '... а какво всъщност е виртуална памет?' do
    list:
        Паметта, до която имат достъп процесите
        Те НЯМАТ достъп до истинските адреси във физическата памет
        Всеки процес има собствена като те не се застъпват
        Всеки процес има право да достъпи пълното адресно пространство
        Виртуалната памет може да не е във физическата (swap file, memory mapped files, etc)


= slide 'Как User space достъпва kernel space' do
    list:
        През така наречените System Calls
        Това са обикновени функции, които можем да викаме
        Намират се в стандартната С блиотека, която върви с всяка ОС
        Те вътрешно ще направят магията


= slide 'Как изглежда един процес във виртуалната памет?' do
    list:
        Всеки процес, очевидно, има изпълним код
        Stacks, heaps, read-only segments
        Отделно има и mapped files, etc


= slide 'Изпълнимите файлове на твърдия диск' do
    list:
        Съдържа кода на приложението
        Може да съдържа кода на външни библиотеки
        Или просто имената на тези външни зависимости
        Примерна зависимост е стандартната С библиотека


= slide 'Как получаваме изпълними файлове?' do
    list:
        Чрез компилация и линкване
        Компилацията превежда отделен файл с програмен код към машинни инструкции
        Линкването "свързва" отделни компилирани единици
        Какво правим с външни зависимости, които не са наш код?
        Като например printf от стандартната С библиотека?


= slide 'DLLs/so\'s' do
    list:
        В изпълнимия файл има единствено имена на библиотеки и функции
        Пример: libc.so:printf или msvcrt.dll:printf
        ОС-а се грижи да "зареди" библиотеката и да навърже адресите


= slide 'Изпълнение на код' do
    list:
        Компютрите "говорят" на машинен език
        Ние програмираме на човешко-четим език
        Трябва някой по някакъв начин трябва да го обърне до машинен, за да може да бъде изпълнен от компютъра
        Има (грубо-казано) 2 начина за това


= slide 'Compilation / Interpretation' do
    list:
        При първия, една програма "превежда" човешкия език на машинен преди изпълнението му
        Тя се нарича компилатор
        Включва процеса на linking, за който говорихме предния път

        При втория, една програма директно изпълнява човешкия език
        Тя се нарича интерпретатор
        Работи на принципа read-eval-print (REPL)


= slide 'Плюсове и минуси' do
    list:
        Компилацията отнема време (C++, anyone?)
        Компилираният код се изпълнява по-бързо
        Времето за зареждане на интерпретиран код може да е голямо
        Интерпретируемите езици нямат нужда от build системи
        По-често (и лесно) се ползват за rapid prototyping
        Компилираният код остава същия през времето
        Това може да е проблем, когато хардуерът става по-добър


= slide 'JIT' do
    list:
        Идеята е да компилираме човешкия език до междинен код
        Който после, по време на изпълнение, се компилира до машинен
        Това, което прави вторичната компилация, се нарича runtime
        Типичните примери за това са .NET/Java


= slide 'Плюсове и минуси' do
    list:
        По-бавен startup time, тъй като се налага междинния код да се транслира
        Евентуално по-бързо изпълнение от чист native код по две причини:
        При дълго вървящи процеси, runtime-ът може да оптимизира hot paths
        Когато upgrade-нем хардуера и runtime-а, всички "стари" програми ще вървят по-бързо
        Доста повече метаинформация, идваща от runtime-a
        Благинки като garbage-collection, reflection


= slide 'Какво съдържа един native DLL/so' do
    list:
        Практически няма разлика между DLL и EXE
        Съдържа изпълним код, import таблица, export таблица
        Последната съдържа само имената на функциите за C DLL-и
        За C++ такива съдържа в името си и имената на типовете на аргументите си
        Не съдържат, обаче, дефиниции на типове
        Как тогава можем да компилираме код, който използва функции от такива DLL-и?


= slide 'В чисто C и C++' do
    list:
        С header файлове. Те съдържат дефинициите на типове, декларации на функции и т.н.


= slide 'В Java/.NET' do
    list:
        Java използва JAR файлове, а в .NET DLL-ите не са (просто) native такива
        В тях има много метаинформация за всички типове, функции, etc


= slide 'Скриптовите езици (Python)' do
    list:
        Те обикновено не се компилират, а интерпретират, което означава, че ship-ват код
        Тогава нямаме проблем с липса на типова информация


= slide 'Memory management' do
    list:
        Всяка програма работи с променливи, които се намират някъде в оперативната памет
        Има няколко подхода за това къде може да се намират
        В read-only паметта, например хардкоднати стойности в кода ни
        На стека, ако това са локални променливи във функции, например
        В heap-a, ако са променливи, които ще ни трябват по-продължително
        За последните някой трябва да се грижи ръчно кога да бъдат освободени


= slide 'Manual memory management' do
    list:
        Езици като C/C++
        Това е най-бързото решение като скорост на изпълнение
        Освобождаваме ресурси максимално бързо, когато не ни трябват
        Стават МНОГО грешки
        Причината за 90% от crash-овете на приложения


= slide 'Garbage collection' do
    list:
        По-модерни езици като Java/.NET/Ruby/Python
        По-бавно по време на изпълнение
        По-късно освобождаване на ресурси
        Но пък е programmer-proof
